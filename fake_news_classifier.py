# -*- coding: utf-8 -*-
"""fake_news_classifier.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uUIwvxLPiQ-bTYoO5W3DPE71TEplvn1k
"""

import pandas as pd

df = pd.read_csv("/content/sample_data/fake_train.csv", header=0)

df.head()

# from google.colab import drive
# drive.mount('/content/drive')

df.columns

df.shape

df.dropna(inplace=True)

df.shape

X=df.drop('label',axis=1)

X.shape

y=df['label']

y.shape

!pip install tensorflow

# pip show tensorflow

# import sys
# print(sys.executable)

!pip install keras

import tensorflow as tf

tf.__version__

# from tensorflow.keras.layers import Embedding, LSTM, Dense
# from tensorflow.keras.preprocessing.sequence import pad_sequence
# from tensorflow.keras.models import Sequential
# from tensorflow.keras.preprocessing.text import one_hot

from tensorflow import keras

from keras.layers import Embedding, LSTM, Dense, Dropout

from keras.preprocessing.sequence import pad_sequences

from tensorflow.keras.preprocessing.sequence import pad_sequences

from keras.models import Sequential

from tensorflow.keras.preprocessing.text import one_hot



voc_size=500

messages=X.copy()

messages.reset_index(inplace=True)

import nltk
import re
from nltk.corpus import stopwords

nltk.download('stopwords')
nltk.download('punkt')
nltk.download('wordnet')

from nltk.corpus import stopwords
from nltk.stem.porter import PorterStemmer
from nltk.stem import WordNetLemmatizer

stemmer=PorterStemmer()
lemmatizer=WordNetLemmatizer()

corpus = []

for i in range(len(messages)):
    print(i)
    review = re.sub('[^a-z A-Z]',' ',messages['title'][i])
    review = review.lower()
    review = review.split()

    review = [lemmatizer.lemmatize(word) for word in review if word not in set(stopwords.words('english'))]
    review = ' '.join(review)
    print(review)
    corpus.append(review)

corpus

## one hot representation

onehot_rep = [one_hot(words,voc_size) for words in corpus]
onehot_rep

## padding 0 -- pre

sent_length = 20
embedded_docs = pad_sequences(onehot_rep, padding="pre", maxlen=sent_length)
print(embedded_docs)

len(embedded_docs)

## creating a simple LSTM Model

embedding_vector_features=40

model=Sequential()
model.add(Embedding(voc_size,embedding_vector_features))
model.add(LSTM(100))
model.add(Dense(1,activation='sigmoid'))
model.compile(loss="binary_crossentropy", optimizer="adam", metrics=["accuracy"])
print(model.summary)

len(embedded_docs),y.shape



import numpy as np

X_final=np.array(embedded_docs)
y_final=np.array(y)

X_final.shape,y_final.shape



from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X_final, y_final, test_size=0.33, random_state=42)



model.fit(X_train,y_train, validation_data=(X_test,y_test), epochs=10, batch_size=64)



y_train_pred = (model.predict(X_train)>0.5).astype("int32")

y_test_pred = (model.predict(X_test)>0.5).astype("int32")

type(y_test), type(y_test_pred)

len(y_test), len(y_test_pred)

y_test.shape, y_test_pred.shape

from sklearn.metrics import confusion_matrix, classification_report, accuracy_score

conf_mat = confusion_matrix(y_test, y_test_pred)
conf_mat

class_rep = classification_report(y_test, y_test_pred)
print(class_rep)

model_accuracy = accuracy_score(y_test, y_test_pred)
model_accuracy



## Enhance the model by adding Dropout

embedding_vector_features=40

model=Sequential()
model.add(Embedding(voc_size,embedding_vector_features))
model.add(Dropout(0.3))
model.add(LSTM(100))
model.add(Dropout(0.3))
model.add(Dense(1,activation='sigmoid'))
model.compile(loss="binary_crossentropy", optimizer="adam", metrics=["accuracy"])
print(model.summary)

model.fit(X_train,y_train, validation_data=(X_test,y_test), epochs=10, batch_size=64)

y_train_pred = (model.predict(X_train)>0.5).astype("int32")

y_test_pred = (model.predict(X_test)>0.5).astype("int32")

from sklearn.metrics import confusion_matrix, classification_report, accuracy_score

conf_mat = confusion_matrix(y_test, y_test_pred)
conf_mat

class_rep = classification_report(y_test, y_test_pred)
print(class_rep)

model_accuracy = accuracy_score(y_test, y_test_pred)
model_accuracy

